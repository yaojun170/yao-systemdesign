# Redis vs ZooKeeper 分布式锁深度对比

## 代码实现

- [基于 Redis 的分布式锁实现](redis-distributed-lock.md)
- [基于 ZooKeeper 的分布式锁实现](zk-distributed-lock.md)
- [基于 MySQL 的分布式锁实现](db-distributelock.md)

## 1. 实现原理对比

### Redis 分布式锁

```
┌─────────────────────────────────────────────────────────────┐
│                    Redis 分布式锁原理                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  加锁: SET lock_key value NX PX timeout                     │
│        └── 原子命令，key不存在才设置                          │
│                                                             │
│  解锁: Lua脚本 (check value & delete)                       │
│        └── 只有持有者才能删除                                 │
│                                                             │
│  续期: Lua脚本 (check value & pexpire)                      │
│        └── 看门狗定期续期                                    │
│                                                             │
│  特点: 基于 "互斥写入" + "过期时间" 实现                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### ZooKeeper 分布式锁

```
┌─────────────────────────────────────────────────────────────┐
│                  ZooKeeper 分布式锁原理                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  加锁: 创建临时顺序节点 /lock/lock-0000000001               │
│        检查是否为最小节点                                     │
│        若不是，监听前一个节点                                 │
│                                                             │
│  解锁: 删除自己创建的临时节点                                 │
│                                                             │
│  自动释放: 临时节点 + 会话心跳                               │
│            客户端崩溃 → 会话超时 → 节点自动删除               │
│                                                             │
│  特点: 基于 "顺序节点" + "Watch机制" 实现                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 核心特性对比

| 特性 | Redis | ZooKeeper |
|------|-------|-----------|
| **一致性模型** | AP（最终一致） | CP（强一致） |
| **加锁机制** | SET NX PX 命令 | 临时顺序节点 |
| **锁失效机制** | 过期时间（需要看门狗续期） | 会话超时（自动） |
| **等待通知** | 轮询（polling） | Watch 回调（事件驱动） |
| **公平性** | 非公平（竞争） | 公平（按顺序） |
| **可重入** | 需手动实现 | Curator 提供支持 |
| **性能** | ⭐⭐⭐⭐⭐ 极高 | ⭐⭐⭐ 中等 |
| **可靠性** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 极高 |

---

## 3. 一致性与可靠性深度分析

### Redis 的问题：主从切换丢锁

```
时间线:
T1: Client A 在 Master 上获取锁 ✅
T2: Master 宕机，锁尚未同步到 Slave
T3: Slave 晋升为新 Master
T4: Client B 在新 Master 上获取同一把锁 ✅
T5: Client A 和 B 都认为自己持有锁！ ❌ 数据不一致
```

**Redis 的应对方案：**

| 方案 | 说明 | 可靠性 |
|------|------|--------|
| 单节点 | 简单但有单点故障 | ⭐⭐ |
| Sentinel | 自动故障转移，但有丢锁风险 | ⭐⭐⭐ |
| Cluster | 分片部署，仍有主从切换问题 | ⭐⭐⭐ |
| RedLock | 多节点多数派，有争议 | ⭐⭐⭐⭐ |

### ZooKeeper 的保证：ZAB 协议

```
ZooKeeper 写入流程:
1. Leader 收到写请求
2. Leader 广播 Proposal 给所有 Follower
3. 过半数 Follower ACK 后，Leader 广播 Commit
4. 数据持久化后才返回成功

结果: 只要 ZK 返回成功，数据一定已在过半节点持久化
      即使 Leader 宕机，新 Leader 也有该数据
```

---

## 4. 性能对比

### 测试场景参考

| 场景 | Redis (单节点) | ZooKeeper (3节点) |
|------|----------------|-------------------|
| 加锁 TPS | ~100,000 | ~10,000 |
| 加锁延迟 | < 1ms | 5-10ms |
| 解锁 TPS | ~100,000 | ~10,000 |
| 网络敏感度 | 低 | 高（需要多数派同步） |

### 性能差异原因

```
Redis:
┌────────┐      SET NX PX      ┌────────┐
│ Client │───────────────────▶│ Redis  │
└────────┘◀───────────────────└────────┘
              OK / nil
           (单次网络往返)

ZooKeeper:
┌────────┐    create     ┌────────────────┐
│ Client │─────────────▶│    Leader      │
└────────┘              └───────┬────────┘
                                │ Proposal
                    ┌───────────┼───────────┐
                    ▼           ▼           ▼
              ┌──────────┐ ┌──────────┐ ┌──────────┐
              │Follower 1│ │Follower 2│ │Follower 3│
              └────┬─────┘ └────┬─────┘ └─────┬────┘
                   │ ACK        │ ACK         │ ACK
                   └────────────┼─────────────┘
                                ▼
                            Commit
                   (多次网络往返 + 磁盘持久化)
```

---

## 5. 等待机制对比

### Redis：轮询等待

```java
while (true) {
    if (tryLock()) {
        return true;
    }
    Thread.sleep(100);  // 轮询间隔
    if (超时) return false;
}
```

**问题：**
- CPU 空转
- 轮询间隔难选择：太短浪费资源，太长响应慢
- 锁释放后，获取延迟 = 0 ~ 轮询间隔

### ZooKeeper：Watch 事件驱动

```java
// 创建顺序节点
String myNode = zk.create("/lock/lock-", EPHEMERAL_SEQUENTIAL);
while (true) {
    List<String> children = zk.getChildren("/lock");
    if (isSmallest(myNode, children)) {
        return true;  // 获取锁成功
    }
    // 监听前一个节点，删除时会收到回调
    String prevNode = getPrevNode(myNode, children);
    zk.exists(prevNode, watchEvent -> {
        // 前一个节点删除时，触发此回调
        latch.countDown();
    });
    latch.await();  // 等待回调，不占用 CPU
}
```

**优势：**
- 精确通知，无 CPU 空转
- 锁释放后，下一个等待者立即感知
- 避免惊群效应（只通知下一个等待者）

---

## 6. 公平性对比

### Redis：非公平锁

```
所有等待者同时竞争，谁抢到算谁的

等待队列:  A(等3秒) B(等2秒) C(等1秒)
锁释放时:  C 可能先抢到（运气好）
结果:      A 可能一直抢不到（饥饿）
```

### ZooKeeper：公平锁

```
按创建顺序排队

节点顺序: lock-0001(A) lock-0002(B) lock-0003(C)
锁释放:   lock-0001 删除
下一个:   lock-0002(B) 获取锁
结果:     严格 FIFO，无饥饿
```

---

## 7. 实际应用注意事项

### Redis 分布式锁注意事项

| 注意点 | 说明 | 解决方案 |
|--------|------|----------|
| **锁过期但业务未完成** | 业务执行时间不可控 | 启用看门狗自动续期 |
| **主从切换丢锁** | 主节点宕机时锁可能丢失 | 业务幂等设计 / 使用 RedLock |
| **锁值唯一性** | 必须全局唯一 | UUID + 机器ID + 线程ID |
| **Lua 脚本原子性** | 解锁必须用 Lua | 禁止 GET + DEL 分离操作 |
| **重入计数** | 本地记录，进程重启丢失 | 重启后视为新客户端 |
| **时钟漂移** | 影响过期时间判断 | NTP 同步 / RedLock 考虑时钟因素 |

### ZooKeeper 分布式锁注意事项

| 注意点 | 说明 | 解决方案 |
|--------|------|----------|
| **会话超时设置** | 太短导致误释放，太长导致故障恢复慢 | 根据网络情况设置（通常 10-30s） |
| **惊群效应** | 多个客户端监听同一节点 | 只监听前一个节点 |
| **临时节点未删除** | 网络分区时客户端认为仍持有锁 | 检查节点是否存在 |
| **连接抖动** | 网络不稳定导致会话重建 | 合理设置重连策略 |
| **写操作瓶颈** | 所有写都经过 Leader | 增加节点只能提高读性能 |

---

## 8. 生产环境选择决策树

```
                    ┌─────────────────────────────┐
                    │ 需要分布式锁                 │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────▼───────────────┐
                    │ 是否需要强一致性保证？        │
                    └─────────────┬───────────────┘
                           │              │
                          是              否
                           │              │
              ┌────────────▼────┐   ┌─────▼──────────────┐
              │ 使用 ZooKeeper  │   │ Redis 是否已在使用？ │
              │ 或 etcd         │   └─────┬──────────────┘
              └─────────────────┘         │           │
                                         是           否
                                          │           │
                              ┌───────────▼───┐  ┌────▼────────────┐
                              │ 使用 Redis    │  │ 考虑引入成本     │
                              │ 分布式锁      │  │ Redis更轻量     │
                              └───────────────┘  │ ZK更可靠        │
                                                 └─────────────────┘
```

---

## 9. 场景化选择建议

| 场景 | 推荐方案 | 理由 |
|------|----------|------|
| **秒杀/抢购** | Redis | 高并发，短时锁，允许极端情况下多卖 |
| **支付/转账** | ZooKeeper | 强一致性，不允许重复扣款 |
| **定时任务调度** | Redis / ZK 均可 | 根据现有技术栈选择 |
| **分布式 ID 生成** | ZooKeeper | 严格顺序性保证 |
| **配置中心选主** | ZooKeeper | 可靠性优先 |
| **缓存重建** | Redis | 高性能，允许重复重建 |
| **订单创建** | ZooKeeper | 防止重复创建 |
| **库存扣减** | Redis + 补偿 | 高并发 + 后台对账补偿 |

---

## 10. 最终总结

```
┌────────────────────────────────────────────────────────────────────┐
│                           选择总结                                  │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  Redis 分布式锁:                                                   │
│  ✅ 性能极高（10万+ TPS）                                          │
│  ✅ 实现简单，运维成本低                                            │
│  ✅ 大多数公司已有 Redis 基础设施                                   │
│  ❌ AP 模型，极端情况可能丢锁                                       │
│  ❌ 需要额外处理续期、重入等问题                                    │
│  📌 适用: 高并发、允许极端情况不一致、追求性能                       │
│                                                                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  ZooKeeper 分布式锁:                                               │
│  ✅ 强一致性保证（CP 模型）                                         │
│  ✅ 公平锁，无饥饿问题                                              │
│  ✅ Watch 机制高效，无需轮询                                        │
│  ✅ 会话机制自动处理客户端崩溃                                      │
│  ❌ 性能相对较低（万级 TPS）                                        │
│  ❌ 运维复杂度高，需要独立集群                                      │
│  📌 适用: 金融交易、强一致性场景、已有 ZK 基础设施                   │
│                                                                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  实践建议:                                                          │
│  1. 大多数场景 Redis 足够，配合业务幂等设计                          │
│  2. 金融核心交易选择 ZooKeeper                                      │
│  3. 无论选择哪个，都要有降级和补偿机制                               │
│  4. 分布式锁不是银弹，优先考虑是否能通过业务设计避免                  │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

